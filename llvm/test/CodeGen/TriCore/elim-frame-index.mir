# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -mtriple=tricore -run-pass=prologepilog -verify-machineinstrs %s -o - | FileCheck %s

--- |
  %struct.bar = type { i32, i32 }

  define dso_local void @test_frame_index_elimination() {
  entry:
    %ptr0 = alloca [65536 x i32], align 4
    %ptr1 = alloca [65536 x i32], align 4
    %ptr2 = alloca %struct.bar, align 4
    ret void
  }

...
---
name:            test_frame_index_elimination
legalized:       true
regBankSelected: true
selected:        true
tracksRegLiveness: true
stack:
  - { id: 0, name: ptr0, type: default, offset: 0, size: 262144, alignment: 4 }
  - { id: 1, name: ptr1, type: default, offset: 0, size: 262144, alignment: 4 }
  - { id: 2, name: ptr2, type: default, offset: 0, size: 8, alignment: 4 }
body:             |
  bb.0.entry:
    ; $a14 is needed as we are not implementing emitProlog/Epilogue yet.
    liveins: $a14, $d4
    ; CHECK-LABEL: name: test_frame_index_elimination
    ; CHECK:      id: 0, name: ptr0, type: default, offset: -262144, size: 262144
    ; CHECK:      id: 1, name: ptr1, type: default, offset: -524288, size: 262144
    ; CHECK:      id: 2, name: ptr2, type: default, offset: -524296, size: 8
    ; CHECK:      liveins: $a14, $d4
    ; CHECK:      $a15 = LEA_aac $a14, 8
    ; CHECK-NEXT: $a15 = ADDIHA_aac $a15, 4
    ; CHECK-NEXT: $a2 = LEA_aac killed $a15, 0
    ; CHECK:      $a3 = LEA_aac $a14, 8
    ; CHECK:      $a4 = LEA_aac $a14, 0
    ; CHECK:      $a15 = LEA_aac $a14, 8
    ; CHECK-NEXT: $a15 = ADDIHA_aac $a15, 4
    ; CHECK-NEXT: STW_alcd killed $a15, 0, $d4 :: (store 4)
    ; CHECK:      STW_alcd $a14, 8, $d4 :: (store 4)
    ; CHECK:      STW_alcd $a14, 0, killed $d4 :: (store 4)
    ; CHECK:      $a15 = LEA_aac $a14, 8
    ; CHECK-NEXT: $a15 = ADDIHA_aac $a15, 4
    ; CHECK-NEXT: $d2 = LDW_dalc killed $a15, 0 :: (load 4)
    ; CHECK:      $d3 = LDW_dalc $a14, 8 :: (load 4)
    ; CHECK:      $d4 = LDW_dalc $a14, 0 :: (load 4)
    $a2 = LEA_aac %stack.0.ptr0, 0
    $a3 = LEA_aac %stack.1.ptr1, 0
    $a4 = LEA_aac %stack.2.ptr2, 0
    STW_alcd %stack.0.ptr0, 0, $d4 :: (store 4)
    STW_alcd %stack.1.ptr1, 0, $d4 :: (store 4)
    STW_alcd %stack.2.ptr2, 0, killed $d4 :: (store 4)
    $d2 = LDW_dalc %stack.0.ptr0, 0 :: (load 4)
    $d3 = LDW_dalc %stack.1.ptr1, 0 :: (load 4)
    $d4 = LDW_dalc %stack.2.ptr2, 0 :: (load 4)
...
