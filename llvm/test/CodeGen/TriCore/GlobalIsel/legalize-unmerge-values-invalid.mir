# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -O0 -mtriple=tricore -global-isel -global-isel-abort=2 -pass-remarks-missed='gisel*' -run-pass=legalizer -verify-machineinstrs %s -o /dev/null 2>&1 | FileCheck %s --check-prefix=ERROR

# The GlobalISel legalizer does not know how to legalize the big type of a
# merge/unmerge. Furthermore, the legalizer does not know how to widen to a
# legal type if the big type is not a scalar. These tests are designed to
# trigger these cases:
#
# test_unmerge_s4_p0 triggers the pointer case
# test_unmerge_s8_s56 triggers the legal-small-type-illegal-big-type case
#
# test_unmerge_s1_s3 is interesting as it is being legalized, but the
# legalization produces an artifact which cannot be legalized due to the same
# case as in test_unmerge_s8_s56. This legalization is an unmerge from s24 to
# s8.
#
# Since this is not something we don't support yet, but simply a short-coming of
# the current GlobalISel framework, this is not an XFAIL test but rather an
# invalid test. If this at one point starts failing we know that this is now
# supported and we can then check whether we handle them correctly.

# ERROR-NOT: remark:
# ERROR: remark: <unknown>:0:0: unable to legalize instruction: %1:_(s4), %2:_(s4), %3:_(s4), %4:_(s4), %5:_(s4), %6:_(s4), %7:_(s4), %8:_(s4) = G_UNMERGE_VALUES %0:_(p0) (in function: test_unmerge_s4_p0)
# ERROR: remark: <unknown>:0:0: unable to legalize instruction: %2:_(s1), %3:_(s1), %4:_(s1) = G_UNMERGE_VALUES %1:_(s3) (in function: test_unmerge_s1_s3)
# ERROR: remark: <unknown>:0:0: unable to legalize instruction: %2:_(s8), %3:_(s8), %4:_(s8), %5:_(s8), %6:_(s8), %7:_(s8), %8:_(s8) = G_UNMERGE_VALUES %1:_(s56) (in function: test_unmerge_s8_s56)
# ERROR-NOT: remark:

---
name: test_unmerge_s4_p0
body: |
  bb.0:
    %0:_(p0) = G_CONSTANT i32 0
    %1:_(s4), %2:_(s4), %3:_(s4), %4:_(s4), %5:_(s4), %6:_(s4), %7:_(s4), %8:_(s4) = G_UNMERGE_VALUES %0:_(p0)
    %9:_(s32) = G_ANYEXT %1
    %10:_(s32) = G_ANYEXT %2
    %11:_(s32) = G_ANYEXT %3
    %12:_(s32) = G_ANYEXT %4
    %13:_(s32) = G_ANYEXT %5
    %14:_(s32) = G_ANYEXT %6
    %15:_(s32) = G_ANYEXT %7
    %16:_(s32) = G_ANYEXT %8
    $d0 = COPY %9(s32)
    $d1 = COPY %10(s32)
    $d2 = COPY %11(s32)
    $d3 = COPY %12(s32)
    $d4 = COPY %13(s32)
    $d5 = COPY %14(s32)
    $d6 = COPY %15(s32)
    $d7 = COPY %16(s32)
...

---
name: test_unmerge_s1_s3
body: |
  bb.0:
    liveins: $d0
    %0:_(s32) = COPY $d0
    %1:_(s3) = G_TRUNC %0
    %2:_(s1), %3:_(s1), %4:_(s1) = G_UNMERGE_VALUES %1
    %5:_(s32) = G_ANYEXT %2
    %6:_(s32) = G_ANYEXT %3
    %7:_(s32) = G_ANYEXT %4
    $d0 = COPY %5
    $d1 = COPY %6
    $d2 = COPY %7
...

---
name: test_unmerge_s8_s56
body: |
  bb.0:
    %0:_(s64) = G_CONSTANT i64 0
    %1:_(s56) = G_TRUNC %0
    %2:_(s8), %3:_(s8), %4:_(s8), %5:_(s8), %6:_(s8), %7:_(s8), %8:_(s8) = G_UNMERGE_VALUES %1
    %10:_(s32) = G_ANYEXT %2
    %11:_(s32) = G_ANYEXT %3
    %12:_(s32) = G_ANYEXT %4
    %13:_(s32) = G_ANYEXT %5
    %14:_(s32) = G_ANYEXT %6
    %15:_(s32) = G_ANYEXT %7
    %16:_(s32) = G_ANYEXT %8
    $d0 = COPY %10
    $d1 = COPY %11
    $d2 = COPY %12
    $d3 = COPY %13
    $d4 = COPY %14
    $d5 = COPY %15
    $d6 = COPY %16
...
